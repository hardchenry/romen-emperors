{"ast":null,"code":"import { normalize_columns_array } from \"./normalize_columns_array.js\";\nimport { init_state } from \"./init_state.js\";\nimport { normalize_options } from \"./normalize_options.js\";\nimport { CsvError } from \"./CsvError.js\";\nconst isRecordEmpty = function (record) {\n  return record.every(field => field == null || field.toString && field.toString().trim() === \"\");\n};\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexad√©cimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  utf8: Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  utf16le: Buffer.from([255, 254])\n};\nconst transform = function (original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function (i, bufLen, end) {\n      if (end) return false;\n      const {\n        encoding,\n        escape,\n        quote\n      } = this.options;\n      const {\n        quoting,\n        needMoreDataSize,\n        recordDelimiterMaxLength\n      } = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(needMoreDataSize,\n      // Skip if the remaining buffer smaller than record delimiter\n      // If \"record_delimiter\" is yet to be discovered:\n      // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n      // 2. We set the length to windows line ending in the current encoding\n      // Note, that encoding is known from user or bom discovery at that point\n      // recordDelimiterMaxLength,\n      recordDelimiterMaxLength === 0 ? Buffer.from(\"\\r\\n\", encoding).length : recordDelimiterMaxLength,\n      // Skip if remaining buffer can be an escaped quote\n      quoting ? (escape === null ? 0 : escape.length) + quote.length : 0,\n      // Skip if remaining buffer can be record delimiter following the closing quote\n      quoting ? quote.length + recordDelimiterMaxLength : 0);\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function (nextBuf, end, push, close) {\n      const {\n        bom,\n        comment_no_infix,\n        encoding,\n        from_line,\n        ltrim,\n        max_record_size,\n        raw,\n        relax_quotes,\n        rtrim,\n        skip_empty_lines,\n        to,\n        to_line\n      } = this.options;\n      let {\n        comment,\n        escape,\n        quote,\n        record_delimiter\n      } = this.options;\n      const {\n        bomSkipped,\n        previousBuf,\n        rawBuffer,\n        escapeIsQuote\n      } = this.state;\n      let buf;\n      if (previousBuf === undefined) {\n        if (nextBuf === undefined) {\n          // Handle empty string\n          close();\n          return;\n        } else {\n          buf = nextBuf;\n        }\n      } else if (previousBuf !== undefined && nextBuf === undefined) {\n        buf = previousBuf;\n      } else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if (bomSkipped === false) {\n        if (bom === false) {\n          this.state.bomSkipped = true;\n        } else if (buf.length < 3) {\n          // No enough data\n          if (end === false) {\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        } else {\n          for (const encoding in boms) {\n            if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({\n                ...this.original_options,\n                encoding: encoding\n              });\n              // Options will re-evaluate the Buffer with the new encoding\n              ({\n                comment,\n                escape,\n                quote\n              } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for (pos = 0; pos < bufLen; pos++) {\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if (this.__needMoreData(pos, bufLen, end)) {\n          break;\n        }\n        if (this.state.wasRowDelimiter === true) {\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if (to_line !== -1 && this.info.lines > to_line) {\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if (this.state.quoting === false && record_delimiter.length === 0) {\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n          if (record_delimiterCount) {\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if (raw === true) {\n          rawBuffer.append(chr);\n        }\n        if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if (this.state.escaping === true) {\n          this.state.escaping = false;\n        } else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {\n            if (escapeIsQuote) {\n              if (this.__isQuote(buf, pos + escape.length)) {\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            } else {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n            if (this.state.quoting === true) {\n              const nextChr = buf[pos + quote.length];\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos + quote.length);\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {\n                pos += escape.length - 1;\n              } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              } else if (relax_quotes === false) {\n                const err = this.__error(new CsvError(\"CSV_INVALID_CLOSING_QUOTE\", [\"Invalid Closing Quote:\", `got \"${String.fromCharCode(nextChr)}\"`, `at line ${this.info.lines}`, \"instead of delimiter, record delimiter, trimable character\", \"(if activated) or comment\"], this.options, this.__infoField()));\n                if (err !== undefined) return err;\n              } else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            } else {\n              if (this.state.field.length !== 0) {\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if (relax_quotes === false) {\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];\n                  const err = this.__error(new CsvError(\"INVALID_OPENING_QUOTE\", [\"Invalid Opening Quote:\", `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`, bom ? `(${bom} bom)` : undefined], this.options, info, {\n                    field: this.state.field\n                  }));\n                  if (err !== undefined) return err;\n                }\n              } else {\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if (this.state.quoting === false) {\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n            if (recordDelimiterLength !== 0) {\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n              if (skipCommentLine) {\n                this.info.comment_lines++;\n                // Skip full comment line\n              } else {\n                // Activate records emition if above from_line\n                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if (errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if (errRecord !== undefined) return errRecord;\n                if (to !== -1 && this.info.records >= to) {\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if (this.state.commenting) {\n              continue;\n            }\n            if (comment !== null && (comment_no_infix === false || this.state.record.length === 0 && this.state.field.length === 0)) {\n              const commentCount = this.__compareBytes(comment, buf, pos, chr);\n              if (commentCount !== 0) {\n                this.state.commenting = true;\n                continue;\n              }\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if (delimiterLength !== 0) {\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if (errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if (this.state.commenting === false) {\n          if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n            return this.__error(new CsvError(\"CSV_MAX_RECORD_SIZE\", [\"Max Record Size:\", \"record exceed the maximum number of tolerated bytes\", `of ${max_record_size}`, `at line ${this.info.lines}`], this.options, this.__infoField()));\n          }\n        }\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if (lappend === true && rappend === true) {\n          this.state.field.append(chr);\n        } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {\n          return this.__error(new CsvError(\"CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE\", [\"Invalid Closing Quote:\", \"found non trimable byte after quote\", `at line ${this.info.lines}`], this.options, this.__infoField()));\n        } else {\n          if (lappend === false) {\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if (end === true) {\n        // Ensure we are not ending in a quoting state\n        if (this.state.quoting === true) {\n          const err = this.__error(new CsvError(\"CSV_QUOTE_NOT_CLOSED\", [\"Quote Not Closed:\", `the parsing is finished with an opening quote at line ${this.info.lines}`], this.options, this.__infoField()));\n          if (err !== undefined) return err;\n        } else {\n          // Skip last line if it has no characters\n          if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if (errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if (errRecord !== undefined) return errRecord;\n          } else if (this.state.wasRowDelimiter === true) {\n            this.info.empty_lines++;\n          } else if (this.state.commenting === true) {\n            this.info.comment_lines++;\n          }\n        }\n      } else {\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function (push) {\n      const {\n        columns,\n        group_columns_by_name,\n        encoding,\n        info,\n        from,\n        relax_column_count,\n        relax_column_count_less,\n        relax_column_count_more,\n        raw,\n        skip_records_with_empty_values\n      } = this.options;\n      const {\n        enabled,\n        record\n      } = this.state;\n      if (enabled === false) {\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if (columns === true) {\n        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if (columns === false && this.info.records === 0) {\n        this.state.expectedRecordLength = recordLength;\n      }\n      if (recordLength !== this.state.expectedRecordLength) {\n        const err = columns === false ? new CsvError(\"CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\", [\"Invalid Record Length:\", `expect ${this.state.expectedRecordLength},`, `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n          record: record\n        }) : new CsvError(\"CSV_RECORD_INCONSISTENT_COLUMNS\", [\"Invalid Record Length:\", `columns length is ${columns.length},`,\n        // rename columns\n        `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n          record: record\n        });\n        if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n          this.info.invalid_field_length++;\n          this.state.error = err;\n          // Error is undefined with skip_records_with_error\n        } else {\n          const finalErr = this.__error(err);\n          if (finalErr) return finalErr;\n        }\n      }\n      if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n        this.__resetRecord();\n        return;\n      }\n      if (this.state.recordHasError === true) {\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if (from === 1 || this.info.records >= from) {\n        const {\n          objname\n        } = this.options;\n        // With columns, records are object\n        if (columns !== false) {\n          const obj = {};\n          // Transform record array to an object\n          for (let i = 0, l = record.length; i < l; i++) {\n            if (columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if (raw === true || info === true) {\n            const extRecord = Object.assign({\n              record: obj\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {});\n            const err = this.__push(objname === undefined ? extRecord : [obj[objname], extRecord], push);\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(objname === undefined ? obj : [obj[objname], obj], push);\n            if (err) {\n              return err;\n            }\n          }\n          // Without columns, records are array\n        } else {\n          if (raw === true || info === true) {\n            const extRecord = Object.assign({\n              record: record\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {});\n            const err = this.__push(objname === undefined ? extRecord : [record[objname], extRecord], push);\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(objname === undefined ? record : [record[objname], record], push);\n            if (err) {\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function (record) {\n      const {\n        firstLineToHeaders\n      } = this.state;\n      try {\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n        if (!Array.isArray(headers)) {\n          return this.__error(new CsvError(\"CSV_INVALID_COLUMN_MAPPING\", [\"Invalid Column Mapping:\", \"expect an array from column function,\", `got ${JSON.stringify(headers)}`], this.options, this.__infoField(), {\n            headers: headers\n          }));\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      } catch (err) {\n        return err;\n      }\n    },\n    __resetRecord: function () {\n      if (this.options.raw === true) {\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function () {\n      const {\n        cast,\n        encoding,\n        rtrim,\n        max_record_size\n      } = this.options;\n      const {\n        enabled,\n        wasQuoting\n      } = this.state;\n      // Short circuit for the from_line options\n      if (enabled === false) {\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if (rtrim === true && wasQuoting === false) {\n        field = field.trimRight();\n      }\n      if (cast === true) {\n        const [err, f] = this.__cast(field);\n        if (err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if (max_record_size !== 0 && typeof field === \"string\") {\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function () {\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function (record, push) {\n      const {\n        on_record\n      } = this.options;\n      if (on_record !== undefined) {\n        const info = this.__infoRecord();\n        try {\n          record = on_record.call(null, record, info);\n        } catch (err) {\n          return err;\n        }\n        if (record === undefined || record === null) {\n          return;\n        }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function (field) {\n      const {\n        columns,\n        relax_column_count\n      } = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n        return [undefined, undefined];\n      }\n      if (this.state.castField !== null) {\n        try {\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        } catch (err) {\n          return [err];\n        }\n      }\n      if (this.__isFloat(field)) {\n        return [undefined, parseFloat(field)];\n      } else if (this.options.cast_date !== false) {\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function (buf, pos) {\n      const isTrim = (buf, pos) => {\n        const {\n          timchars\n        } = this.state;\n        loop1: for (let i = 0; i < timchars.length; i++) {\n          const timchar = timchars[i];\n          for (let j = 0; j < timchar.length; j++) {\n            if (timchar[j] !== buf[pos + j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function (value) {\n      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function (sourceBuf, targetBuf, targetPos, firstByte) {\n      if (sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for (let i = 1; i < sourceLength; i++) {\n        if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function (buf, pos, chr) {\n      const {\n        delimiter,\n        ignore_last_delimiters\n      } = this.options;\n      if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {\n        return 0;\n      } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === \"number\" && this.state.record.length === ignore_last_delimiters - 1) {\n        return 0;\n      }\n      loop1: for (let i = 0; i < delimiter.length; i++) {\n        const del = delimiter[i];\n        if (del[0] === chr) {\n          for (let j = 1; j < del.length; j++) {\n            if (del[j] !== buf[pos + j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function (chr, buf, pos) {\n      const {\n        record_delimiter\n      } = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for (let i = 0; i < recordDelimiterLength; i++) {\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if (rd[0] !== chr) {\n          continue;\n        }\n        for (let j = 1; j < rdLength; j++) {\n          if (rd[j] !== buf[pos + j]) {\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function (buf, pos, chr) {\n      const {\n        escape\n      } = this.options;\n      if (escape === null) return false;\n      const l = escape.length;\n      if (escape[0] === chr) {\n        for (let i = 0; i < l; i++) {\n          if (escape[i] !== buf[pos + i]) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function (buf, pos) {\n      const {\n        quote\n      } = this.options;\n      if (quote === null) return false;\n      const l = quote.length;\n      for (let i = 0; i < l; i++) {\n        if (quote[i] !== buf[pos + i]) {\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function (buf, pos) {\n      const {\n        encoding\n      } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n      // Important, the windows line ending must be before mac os 9\n      Buffer.from(\"\\r\\n\", encoding), Buffer.from(\"\\n\", encoding), Buffer.from(\"\\r\", encoding)];\n      loop: for (let i = 0; i < rds.length; i++) {\n        const l = rds[i].length;\n        for (let j = 0; j < l; j++) {\n          if (rds[i][j] !== buf[pos + j]) {\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function (msg) {\n      const {\n        encoding,\n        raw,\n        skip_records_with_error\n      } = this.options;\n      const err = typeof msg === \"string\" ? new Error(msg) : msg;\n      if (skip_records_with_error) {\n        this.state.recordHasError = true;\n        if (this.options.on_skip !== undefined) {\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      } else {\n        return err;\n      }\n    },\n    __infoDataSet: function () {\n      return {\n        ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function () {\n      const {\n        columns,\n        raw,\n        encoding\n      } = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function () {\n      const {\n        columns\n      } = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n        quoting: this.state.wasQuoting\n      };\n    }\n  };\n};\nexport { transform, CsvError };","map":{"version":3,"names":["normalize_columns_array","init_state","normalize_options","CsvError","isRecordEmpty","record","every","field","toString","trim","cr","nl","boms","utf8","Buffer","from","utf16le","transform","original_options","info","bytes","comment_lines","empty_lines","invalid_field_length","lines","records","options","state","__needMoreData","i","bufLen","end","encoding","escape","quote","quoting","needMoreDataSize","recordDelimiterMaxLength","numOfCharLeft","requiredLength","Math","max","length","parse","nextBuf","push","close","bom","comment_no_infix","from_line","ltrim","max_record_size","raw","relax_quotes","rtrim","skip_empty_lines","to","to_line","comment","record_delimiter","bomSkipped","previousBuf","rawBuffer","escapeIsQuote","buf","undefined","concat","compare","bomLength","bufBytesStart","slice","pos","wasRowDelimiter","stop","record_delimiterCount","__autoDiscoverRecordDelimiter","chr","append","escaping","__isEscape","__isQuote","commenting","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRecordDelimiter","__isRecordDelimiter","wasQuoting","err","__error","String","fromCharCode","__infoField","prepend","Object","keys","map","b","equals","filter","Boolean","JSON","stringify","column","recordDelimiterLength","skipCommentLine","enabled","__resetField","__resetRecord","errField","__onField","errRecord","__onRecord","commentCount","delimiterLength","record_length","lappend","rappend","columns","group_columns_by_name","relax_column_count","relax_column_count_less","relax_column_count_more","skip_records_with_empty_values","recordLength","__firstLineToColumns","expectedRecordLength","error","finalErr","recordHasError","objname","obj","l","disabled","name","Array","isArray","extRecord","assign","__infoRecord","__push","firstLineToHeaders","headers","call","normalizedHeaders","reset","cast","trimRight","f","__cast","on_record","isColumns","castField","__isFloat","parseFloat","cast_date","isTrim","timchars","loop1","timchar","j","value","sourceBuf","targetBuf","targetPos","firstByte","sourceLength","delimiter","ignore_last_delimiters","del","rd","rdLength","rds","loop","msg","skip_records_with_error","Error","on_skip","__infoDataSet","header","index"],"sources":["C:/Projects/roman-emperors/node_modules/csv-parse/lib/api/index.js"],"sourcesContent":["import { normalize_columns_array } from \"./normalize_columns_array.js\";\nimport { init_state } from \"./init_state.js\";\nimport { normalize_options } from \"./normalize_options.js\";\nimport { CsvError } from \"./CsvError.js\";\n\nconst isRecordEmpty = function (record) {\n  return record.every(\n    (field) =>\n      field == null || (field.toString && field.toString().trim() === \"\"),\n  );\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexad√©cimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  utf8: Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  utf16le: Buffer.from([255, 254]),\n};\n\nconst transform = function (original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0,\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function (i, bufLen, end) {\n      if (end) return false;\n      const { encoding, escape, quote } = this.options;\n      const { quoting, needMoreDataSize, recordDelimiterMaxLength } =\n        this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(\n        needMoreDataSize,\n        // Skip if the remaining buffer smaller than record delimiter\n        // If \"record_delimiter\" is yet to be discovered:\n        // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n        // 2. We set the length to windows line ending in the current encoding\n        // Note, that encoding is known from user or bom discovery at that point\n        // recordDelimiterMaxLength,\n        recordDelimiterMaxLength === 0\n          ? Buffer.from(\"\\r\\n\", encoding).length\n          : recordDelimiterMaxLength,\n        // Skip if remaining buffer can be an escaped quote\n        quoting ? (escape === null ? 0 : escape.length) + quote.length : 0,\n        // Skip if remaining buffer can be record delimiter following the closing quote\n        quoting ? quote.length + recordDelimiterMaxLength : 0,\n      );\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function (nextBuf, end, push, close) {\n      const {\n        bom,\n        comment_no_infix,\n        encoding,\n        from_line,\n        ltrim,\n        max_record_size,\n        raw,\n        relax_quotes,\n        rtrim,\n        skip_empty_lines,\n        to,\n        to_line,\n      } = this.options;\n      let { comment, escape, quote, record_delimiter } = this.options;\n      const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;\n      let buf;\n      if (previousBuf === undefined) {\n        if (nextBuf === undefined) {\n          // Handle empty string\n          close();\n          return;\n        } else {\n          buf = nextBuf;\n        }\n      } else if (previousBuf !== undefined && nextBuf === undefined) {\n        buf = previousBuf;\n      } else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if (bomSkipped === false) {\n        if (bom === false) {\n          this.state.bomSkipped = true;\n        } else if (buf.length < 3) {\n          // No enough data\n          if (end === false) {\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        } else {\n          for (const encoding in boms) {\n            if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({\n                ...this.original_options,\n                encoding: encoding,\n              });\n              // Options will re-evaluate the Buffer with the new encoding\n              ({ comment, escape, quote } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for (pos = 0; pos < bufLen; pos++) {\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if (this.__needMoreData(pos, bufLen, end)) {\n          break;\n        }\n        if (this.state.wasRowDelimiter === true) {\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if (to_line !== -1 && this.info.lines > to_line) {\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if (this.state.quoting === false && record_delimiter.length === 0) {\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(\n            buf,\n            pos,\n          );\n          if (record_delimiterCount) {\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if (raw === true) {\n          rawBuffer.append(chr);\n        }\n        if (\n          (chr === cr || chr === nl) &&\n          this.state.wasRowDelimiter === false\n        ) {\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if (this.state.escaping === true) {\n          this.state.escaping = false;\n        } else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if (\n            escape !== null &&\n            this.state.quoting === true &&\n            this.__isEscape(buf, pos, chr) &&\n            pos + escape.length < bufLen\n          ) {\n            if (escapeIsQuote) {\n              if (this.__isQuote(buf, pos + escape.length)) {\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            } else {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n            if (this.state.quoting === true) {\n              const nextChr = buf[pos + quote.length];\n              const isNextChrTrimable =\n                rtrim && this.__isCharTrimable(buf, pos + quote.length);\n              const isNextChrComment =\n                comment !== null &&\n                this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(\n                buf,\n                pos + quote.length,\n                nextChr,\n              );\n              const isNextChrRecordDelimiter =\n                record_delimiter.length === 0\n                  ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length)\n                  : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if (\n                escape !== null &&\n                this.__isEscape(buf, pos, chr) &&\n                this.__isQuote(buf, pos + escape.length)\n              ) {\n                pos += escape.length - 1;\n              } else if (\n                !nextChr ||\n                isNextChrDelimiter ||\n                isNextChrRecordDelimiter ||\n                isNextChrComment ||\n                isNextChrTrimable\n              ) {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              } else if (relax_quotes === false) {\n                const err = this.__error(\n                  new CsvError(\n                    \"CSV_INVALID_CLOSING_QUOTE\",\n                    [\n                      \"Invalid Closing Quote:\",\n                      `got \"${String.fromCharCode(nextChr)}\"`,\n                      `at line ${this.info.lines}`,\n                      \"instead of delimiter, record delimiter, trimable character\",\n                      \"(if activated) or comment\",\n                    ],\n                    this.options,\n                    this.__infoField(),\n                  ),\n                );\n                if (err !== undefined) return err;\n              } else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            } else {\n              if (this.state.field.length !== 0) {\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if (relax_quotes === false) {\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms)\n                    .map((b) =>\n                      boms[b].equals(this.state.field.toString()) ? b : false,\n                    )\n                    .filter(Boolean)[0];\n                  const err = this.__error(\n                    new CsvError(\n                      \"INVALID_OPENING_QUOTE\",\n                      [\n                        \"Invalid Opening Quote:\",\n                        `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,\n                        bom ? `(${bom} bom)` : undefined,\n                      ],\n                      this.options,\n                      info,\n                      {\n                        field: this.state.field,\n                      },\n                    ),\n                  );\n                  if (err !== undefined) return err;\n                }\n              } else {\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if (this.state.quoting === false) {\n            const recordDelimiterLength = this.__isRecordDelimiter(\n              chr,\n              buf,\n              pos,\n            );\n            if (recordDelimiterLength !== 0) {\n              // Do not emit comments which take a full line\n              const skipCommentLine =\n                this.state.commenting &&\n                this.state.wasQuoting === false &&\n                this.state.record.length === 0 &&\n                this.state.field.length === 0;\n              if (skipCommentLine) {\n                this.info.comment_lines++;\n                // Skip full comment line\n              } else {\n                // Activate records emition if above from_line\n                if (\n                  this.state.enabled === false &&\n                  this.info.lines +\n                    (this.state.wasRowDelimiter === true ? 1 : 0) >=\n                    from_line\n                ) {\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if (\n                  skip_empty_lines === true &&\n                  this.state.wasQuoting === false &&\n                  this.state.record.length === 0 &&\n                  this.state.field.length === 0\n                ) {\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if (errField !== undefined) return errField;\n                this.info.bytes =\n                  this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if (errRecord !== undefined) return errRecord;\n                if (to !== -1 && this.info.records >= to) {\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if (this.state.commenting) {\n              continue;\n            }\n            if (\n              comment !== null &&\n              (comment_no_infix === false ||\n                (this.state.record.length === 0 &&\n                  this.state.field.length === 0))\n            ) {\n              const commentCount = this.__compareBytes(comment, buf, pos, chr);\n              if (commentCount !== 0) {\n                this.state.commenting = true;\n                continue;\n              }\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if (delimiterLength !== 0) {\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if (errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if (this.state.commenting === false) {\n          if (\n            max_record_size !== 0 &&\n            this.state.record_length + this.state.field.length > max_record_size\n          ) {\n            return this.__error(\n              new CsvError(\n                \"CSV_MAX_RECORD_SIZE\",\n                [\n                  \"Max Record Size:\",\n                  \"record exceed the maximum number of tolerated bytes\",\n                  `of ${max_record_size}`,\n                  `at line ${this.info.lines}`,\n                ],\n                this.options,\n                this.__infoField(),\n              ),\n            );\n          }\n        }\n        const lappend =\n          ltrim === false ||\n          this.state.quoting === true ||\n          this.state.field.length !== 0 ||\n          !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if (lappend === true && rappend === true) {\n          this.state.field.append(chr);\n        } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {\n          return this.__error(\n            new CsvError(\n              \"CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE\",\n              [\n                \"Invalid Closing Quote:\",\n                \"found non trimable byte after quote\",\n                `at line ${this.info.lines}`,\n              ],\n              this.options,\n              this.__infoField(),\n            ),\n          );\n        } else {\n          if (lappend === false) {\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if (end === true) {\n        // Ensure we are not ending in a quoting state\n        if (this.state.quoting === true) {\n          const err = this.__error(\n            new CsvError(\n              \"CSV_QUOTE_NOT_CLOSED\",\n              [\n                \"Quote Not Closed:\",\n                `the parsing is finished with an opening quote at line ${this.info.lines}`,\n              ],\n              this.options,\n              this.__infoField(),\n            ),\n          );\n          if (err !== undefined) return err;\n        } else {\n          // Skip last line if it has no characters\n          if (\n            this.state.wasQuoting === true ||\n            this.state.record.length !== 0 ||\n            this.state.field.length !== 0\n          ) {\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if (errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if (errRecord !== undefined) return errRecord;\n          } else if (this.state.wasRowDelimiter === true) {\n            this.info.empty_lines++;\n          } else if (this.state.commenting === true) {\n            this.info.comment_lines++;\n          }\n        }\n      } else {\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function (push) {\n      const {\n        columns,\n        group_columns_by_name,\n        encoding,\n        info,\n        from,\n        relax_column_count,\n        relax_column_count_less,\n        relax_column_count_more,\n        raw,\n        skip_records_with_empty_values,\n      } = this.options;\n      const { enabled, record } = this.state;\n      if (enabled === false) {\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if (columns === true) {\n        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if (columns === false && this.info.records === 0) {\n        this.state.expectedRecordLength = recordLength;\n      }\n      if (recordLength !== this.state.expectedRecordLength) {\n        const err =\n          columns === false\n            ? new CsvError(\n                \"CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\",\n                [\n                  \"Invalid Record Length:\",\n                  `expect ${this.state.expectedRecordLength},`,\n                  `got ${recordLength} on line ${this.info.lines}`,\n                ],\n                this.options,\n                this.__infoField(),\n                {\n                  record: record,\n                },\n              )\n            : new CsvError(\n                \"CSV_RECORD_INCONSISTENT_COLUMNS\",\n                [\n                  \"Invalid Record Length:\",\n                  `columns length is ${columns.length},`, // rename columns\n                  `got ${recordLength} on line ${this.info.lines}`,\n                ],\n                this.options,\n                this.__infoField(),\n                {\n                  record: record,\n                },\n              );\n        if (\n          relax_column_count === true ||\n          (relax_column_count_less === true &&\n            recordLength < this.state.expectedRecordLength) ||\n          (relax_column_count_more === true &&\n            recordLength > this.state.expectedRecordLength)\n        ) {\n          this.info.invalid_field_length++;\n          this.state.error = err;\n          // Error is undefined with skip_records_with_error\n        } else {\n          const finalErr = this.__error(err);\n          if (finalErr) return finalErr;\n        }\n      }\n      if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n        this.__resetRecord();\n        return;\n      }\n      if (this.state.recordHasError === true) {\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if (from === 1 || this.info.records >= from) {\n        const { objname } = this.options;\n        // With columns, records are object\n        if (columns !== false) {\n          const obj = {};\n          // Transform record array to an object\n          for (let i = 0, l = record.length; i < l; i++) {\n            if (columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (\n              group_columns_by_name === true &&\n              obj[columns[i].name] !== undefined\n            ) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if (raw === true || info === true) {\n            const extRecord = Object.assign(\n              { record: obj },\n              raw === true\n                ? { raw: this.state.rawBuffer.toString(encoding) }\n                : {},\n              info === true ? { info: this.__infoRecord() } : {},\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [obj[objname], extRecord],\n              push,\n            );\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(\n              objname === undefined ? obj : [obj[objname], obj],\n              push,\n            );\n            if (err) {\n              return err;\n            }\n          }\n          // Without columns, records are array\n        } else {\n          if (raw === true || info === true) {\n            const extRecord = Object.assign(\n              { record: record },\n              raw === true\n                ? { raw: this.state.rawBuffer.toString(encoding) }\n                : {},\n              info === true ? { info: this.__infoRecord() } : {},\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [record[objname], extRecord],\n              push,\n            );\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(\n              objname === undefined ? record : [record[objname], record],\n              push,\n            );\n            if (err) {\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function (record) {\n      const { firstLineToHeaders } = this.state;\n      try {\n        const headers =\n          firstLineToHeaders === undefined\n            ? record\n            : firstLineToHeaders.call(null, record);\n        if (!Array.isArray(headers)) {\n          return this.__error(\n            new CsvError(\n              \"CSV_INVALID_COLUMN_MAPPING\",\n              [\n                \"Invalid Column Mapping:\",\n                \"expect an array from column function,\",\n                `got ${JSON.stringify(headers)}`,\n              ],\n              this.options,\n              this.__infoField(),\n              {\n                headers: headers,\n              },\n            ),\n          );\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      } catch (err) {\n        return err;\n      }\n    },\n    __resetRecord: function () {\n      if (this.options.raw === true) {\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function () {\n      const { cast, encoding, rtrim, max_record_size } = this.options;\n      const { enabled, wasQuoting } = this.state;\n      // Short circuit for the from_line options\n      if (enabled === false) {\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if (rtrim === true && wasQuoting === false) {\n        field = field.trimRight();\n      }\n      if (cast === true) {\n        const [err, f] = this.__cast(field);\n        if (err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if (max_record_size !== 0 && typeof field === \"string\") {\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function () {\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function (record, push) {\n      const { on_record } = this.options;\n      if (on_record !== undefined) {\n        const info = this.__infoRecord();\n        try {\n          record = on_record.call(null, record, info);\n        } catch (err) {\n          return err;\n        }\n        if (record === undefined || record === null) {\n          return;\n        }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function (field) {\n      const { columns, relax_column_count } = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if (\n        isColumns === true &&\n        relax_column_count &&\n        this.options.columns.length <= this.state.record.length\n      ) {\n        return [undefined, undefined];\n      }\n      if (this.state.castField !== null) {\n        try {\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        } catch (err) {\n          return [err];\n        }\n      }\n      if (this.__isFloat(field)) {\n        return [undefined, parseFloat(field)];\n      } else if (this.options.cast_date !== false) {\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function (buf, pos) {\n      const isTrim = (buf, pos) => {\n        const { timchars } = this.state;\n        loop1: for (let i = 0; i < timchars.length; i++) {\n          const timchar = timchars[i];\n          for (let j = 0; j < timchar.length; j++) {\n            if (timchar[j] !== buf[pos + j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function (value) {\n      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function (sourceBuf, targetBuf, targetPos, firstByte) {\n      if (sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for (let i = 1; i < sourceLength; i++) {\n        if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function (buf, pos, chr) {\n      const { delimiter, ignore_last_delimiters } = this.options;\n      if (\n        ignore_last_delimiters === true &&\n        this.state.record.length === this.options.columns.length - 1\n      ) {\n        return 0;\n      } else if (\n        ignore_last_delimiters !== false &&\n        typeof ignore_last_delimiters === \"number\" &&\n        this.state.record.length === ignore_last_delimiters - 1\n      ) {\n        return 0;\n      }\n      loop1: for (let i = 0; i < delimiter.length; i++) {\n        const del = delimiter[i];\n        if (del[0] === chr) {\n          for (let j = 1; j < del.length; j++) {\n            if (del[j] !== buf[pos + j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function (chr, buf, pos) {\n      const { record_delimiter } = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for (let i = 0; i < recordDelimiterLength; i++) {\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if (rd[0] !== chr) {\n          continue;\n        }\n        for (let j = 1; j < rdLength; j++) {\n          if (rd[j] !== buf[pos + j]) {\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function (buf, pos, chr) {\n      const { escape } = this.options;\n      if (escape === null) return false;\n      const l = escape.length;\n      if (escape[0] === chr) {\n        for (let i = 0; i < l; i++) {\n          if (escape[i] !== buf[pos + i]) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function (buf, pos) {\n      const { quote } = this.options;\n      if (quote === null) return false;\n      const l = quote.length;\n      for (let i = 0; i < l; i++) {\n        if (quote[i] !== buf[pos + i]) {\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function (buf, pos) {\n      const { encoding } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n        // Important, the windows line ending must be before mac os 9\n        Buffer.from(\"\\r\\n\", encoding),\n        Buffer.from(\"\\n\", encoding),\n        Buffer.from(\"\\r\", encoding),\n      ];\n      loop: for (let i = 0; i < rds.length; i++) {\n        const l = rds[i].length;\n        for (let j = 0; j < l; j++) {\n          if (rds[i][j] !== buf[pos + j]) {\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function (msg) {\n      const { encoding, raw, skip_records_with_error } = this.options;\n      const err = typeof msg === \"string\" ? new Error(msg) : msg;\n      if (skip_records_with_error) {\n        this.state.recordHasError = true;\n        if (this.options.on_skip !== undefined) {\n          this.options.on_skip(\n            err,\n            raw ? this.state.rawBuffer.toString(encoding) : undefined,\n          );\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      } else {\n        return err;\n      }\n    },\n    __infoDataSet: function () {\n      return {\n        ...this.info,\n        columns: this.options.columns,\n      };\n    },\n    __infoRecord: function () {\n      const { columns, raw, encoding } = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined,\n      };\n    },\n    __infoField: function () {\n      const { columns } = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column:\n          isColumns === true\n            ? columns.length > this.state.record.length\n              ? columns[this.state.record.length].name\n              : null\n            : this.state.record.length,\n        quoting: this.state.wasQuoting,\n      };\n    },\n  };\n};\n\nexport { transform, CsvError };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}